defmodule CDPotion.Domain.Input do
  use CDPotion.Utils
  @typedoc "description not provided :("
  @type drag_data :: %{
          dragOperationsMask: integer(),
          files: list(String.t()) | nil,
          items: list(CDPotion.Domain.Input.drag_data_item())
        }

  @typedoc "description not provided :("
  @type drag_data_item :: %{
          baseURL: String.t() | nil,
          data: String.t(),
          mimeType: String.t(),
          title: String.t() | nil
        }

  @typedoc "description not provided :("
  @type gesture_source_type :: :default | :touch | :mouse

  @typedoc "description not provided :("
  @type mouse_button :: :none | :left | :middle | :right | :back | :forward

  @typedoc "UTC time in seconds, counted from January 1, 1970."
  @type time_since_epoch :: number()

  @typedoc "description not provided :("
  @type touch_point :: %{
          force: number() | nil,
          id: number() | nil,
          radiusX: number() | nil,
          radiusY: number() | nil,
          rotationAngle: number() | nil,
          tangentialPressure: number() | nil,
          tiltX: integer() | nil,
          tiltY: integer() | nil,
          twist: integer() | nil,
          x: number(),
          y: number()
        }

  @doc """
  Dispatches a drag event into the page.
  ## Parameters:
    - `type`:Type of the drag event.
  - `x`:X coordinate of the event relative to the main frame's viewport in CSS pixels.
  - `y`:Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
  the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
  - `data`:description not provided :(
  - `modifiers`:(Optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
  (default: 0).
  """
  @spec dispatch_drag_event(
          String.t(),
          number(),
          number(),
          CDPotion.Domain.Input.DragData,
          integer()
        ) :: {String.t(), map()}
  def dispatch_drag_event(type, x, y, data, modifiers \\ nil) do
    params =
      as_query([{"type", type}, {"x", x}, {"y", y}, {"data", data}, {"modifiers", modifiers}])

    {"Input.dispatchDragEvent", params}
  end

  @doc """
  Dispatches a key event to the page.
  ## Parameters:
    - `type`:Type of the key event.
  - `modifiers`:(Optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
  (default: 0).
  - `timestamp`:(Optional) Time at which the event occurred.
  - `text`:(Optional) Text as generated by processing a virtual key code with a keyboard layout. Not needed for
  for `keyUp` and `rawKeyDown` events (default: "")
  - `unmodified_text`:(Optional) Text that would have been generated by the keyboard if no modifiers were pressed (except for
  shift). Useful for shortcut (accelerator) key handling (default: "").
  - `key_identifier`:(Optional) Unique key identifier (e.g., 'U+0041') (default: "").
  - `code`:(Optional) Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
  - `key`:(Optional) Unique DOM defined string value describing the meaning of the key in the context of active
  modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
  - `windows_virtual_key_code`:(Optional) Windows virtual key code (default: 0).
  - `native_virtual_key_code`:(Optional) Native virtual key code (default: 0).
  - `auto_repeat`:(Optional) Whether the event was generated from auto repeat (default: false).
  - `is_keypad`:(Optional) Whether the event was generated from the keypad (default: false).
  - `is_system_key`:(Optional) Whether the event was a system key event (default: false).
  - `location`:(Optional) Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
  0).
  - `commands`:(Optional) Editing commands to send with the key event (e.g., 'selectAll') (default: []).
  These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
  See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
  """
  @spec dispatch_key_event(
          String.t(),
          integer(),
          CDPotion.Domain.Input.TimeSinceEpoch,
          String.t(),
          String.t(),
          String.t(),
          String.t(),
          String.t(),
          integer(),
          integer(),
          boolean(),
          boolean(),
          boolean(),
          integer(),
          list(String.t())
        ) :: {String.t(), map()}
  def dispatch_key_event(
        type,
        modifiers \\ nil,
        timestamp \\ nil,
        text \\ nil,
        unmodified_text \\ nil,
        key_identifier \\ nil,
        code \\ nil,
        key \\ nil,
        windows_virtual_key_code \\ nil,
        native_virtual_key_code \\ nil,
        auto_repeat \\ nil,
        is_keypad \\ nil,
        is_system_key \\ nil,
        location \\ nil,
        commands \\ nil
      ) do
    params =
      as_query([
        {"type", type},
        {"modifiers", modifiers},
        {"timestamp", timestamp},
        {"text", text},
        {"unmodifiedText", unmodified_text},
        {"keyIdentifier", key_identifier},
        {"code", code},
        {"key", key},
        {"windowsVirtualKeyCode", windows_virtual_key_code},
        {"nativeVirtualKeyCode", native_virtual_key_code},
        {"autoRepeat", auto_repeat},
        {"isKeypad", is_keypad},
        {"isSystemKey", is_system_key},
        {"location", location},
        {"commands", commands}
      ])

    {"Input.dispatchKeyEvent", params}
  end

  @doc """
  This method emulates inserting text that doesn't come from a key press,
  for example an emoji keyboard or an IME.
  ## Parameters:
    - `text`:The text to insert.
  """
  @spec insert_text(String.t()) :: {String.t(), map()}
  def insert_text(text) do
    params = as_query([{"text", text}])
    {"Input.insertText", params}
  end

  @doc """
  This method sets the current candidate text for ime.
  Use imeCommitComposition to commit the final text.
  Use imeSetComposition with empty string as text to cancel composition.
  ## Parameters:
    - `text`:The text to insert
  - `selection_start`:selection start
  - `selection_end`:selection end
  - `replacement_start`:(Optional) replacement start
  - `replacement_end`:(Optional) replacement end
  """
  @spec ime_set_composition(String.t(), integer(), integer(), integer(), integer()) ::
          {String.t(), map()}
  def ime_set_composition(
        text,
        selection_start,
        selection_end,
        replacement_start \\ nil,
        replacement_end \\ nil
      ) do
    params =
      as_query([
        {"text", text},
        {"selectionStart", selection_start},
        {"selectionEnd", selection_end},
        {"replacementStart", replacement_start},
        {"replacementEnd", replacement_end}
      ])

    {"Input.imeSetComposition", params}
  end

  @doc """
  Dispatches a mouse event to the page.
  ## Parameters:
    - `type`:Type of the mouse event.
  - `x`:X coordinate of the event relative to the main frame's viewport in CSS pixels.
  - `y`:Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
  the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
  - `modifiers`:(Optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
  (default: 0).
  - `timestamp`:(Optional) Time at which the event occurred.
  - `button`:(Optional) Mouse button (default: "none").
  - `buttons`:(Optional) A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
  Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
  - `click_count`:(Optional) Number of times the mouse button was clicked (default: 0).
  - `force`:(Optional) The normalized pressure, which has a range of [0,1] (default: 0).
  - `tangential_pressure`:(Optional) The normalized tangential pressure, which has a range of [-1,1] (default: 0).
  - `tilt_x`:(Optional) The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
  - `tilt_y`:(Optional) The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
  - `twist`:(Optional) The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
  - `delta_x`:(Optional) X delta in CSS pixels for mouse wheel event (default: 0).
  - `delta_y`:(Optional) Y delta in CSS pixels for mouse wheel event (default: 0).
  - `pointer_type`:(Optional) Pointer type (default: "mouse").
  """
  @spec dispatch_mouse_event(
          String.t(),
          number(),
          number(),
          integer(),
          CDPotion.Domain.Input.TimeSinceEpoch,
          CDPotion.Domain.Input.MouseButton,
          integer(),
          integer(),
          number(),
          number(),
          integer(),
          integer(),
          integer(),
          number(),
          number(),
          String.t()
        ) :: {String.t(), map()}
  def dispatch_mouse_event(
        type,
        x,
        y,
        modifiers \\ nil,
        timestamp \\ nil,
        button \\ nil,
        buttons \\ nil,
        click_count \\ nil,
        force \\ nil,
        tangential_pressure \\ nil,
        tilt_x \\ nil,
        tilt_y \\ nil,
        twist \\ nil,
        delta_x \\ nil,
        delta_y \\ nil,
        pointer_type \\ nil
      ) do
    params =
      as_query([
        {"type", type},
        {"x", x},
        {"y", y},
        {"modifiers", modifiers},
        {"timestamp", timestamp},
        {"button", button},
        {"buttons", buttons},
        {"clickCount", click_count},
        {"force", force},
        {"tangentialPressure", tangential_pressure},
        {"tiltX", tilt_x},
        {"tiltY", tilt_y},
        {"twist", twist},
        {"deltaX", delta_x},
        {"deltaY", delta_y},
        {"pointerType", pointer_type}
      ])

    {"Input.dispatchMouseEvent", params}
  end

  @doc """
  Dispatches a touch event to the page.
  ## Parameters:
    - `type`:Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
  TouchStart and TouchMove must contains at least one.
  - `touch_points`:Active touch points on the touch device. One event per any changed point (compared to
  previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
  one by one.
  - `modifiers`:(Optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
  (default: 0).
  - `timestamp`:(Optional) Time at which the event occurred.
  """
  @spec dispatch_touch_event(
          String.t(),
          list(CDPotion.Domain.Input.TouchPoint),
          integer(),
          CDPotion.Domain.Input.TimeSinceEpoch
        ) :: {String.t(), map()}
  def dispatch_touch_event(type, touch_points, modifiers \\ nil, timestamp \\ nil) do
    params =
      as_query([
        {"type", type},
        {"touchPoints", touch_points},
        {"modifiers", modifiers},
        {"timestamp", timestamp}
      ])

    {"Input.dispatchTouchEvent", params}
  end

  @doc """
  Cancels any active dragging in the page.
  """
  @spec cancel_dragging() :: {String.t(), map()}
  def cancel_dragging() do
    {"Input.cancelDragging", %{}}
  end

  @doc """
  Emulates touch event from the mouse event parameters.
  ## Parameters:
    - `type`:Type of the mouse event.
  - `x`:X coordinate of the mouse pointer in DIP.
  - `y`:Y coordinate of the mouse pointer in DIP.
  - `button`:Mouse button. Only "none", "left", "right" are supported.
  - `timestamp`:(Optional) Time at which the event occurred (default: current time).
  - `delta_x`:(Optional) X delta in DIP for mouse wheel event (default: 0).
  - `delta_y`:(Optional) Y delta in DIP for mouse wheel event (default: 0).
  - `modifiers`:(Optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
  (default: 0).
  - `click_count`:(Optional) Number of times the mouse button was clicked (default: 0).
  """
  @spec emulate_touch_from_mouse_event(
          String.t(),
          integer(),
          integer(),
          CDPotion.Domain.Input.MouseButton,
          CDPotion.Domain.Input.TimeSinceEpoch,
          number(),
          number(),
          integer(),
          integer()
        ) :: {String.t(), map()}
  def emulate_touch_from_mouse_event(
        type,
        x,
        y,
        button,
        timestamp \\ nil,
        delta_x \\ nil,
        delta_y \\ nil,
        modifiers \\ nil,
        click_count \\ nil
      ) do
    params =
      as_query([
        {"type", type},
        {"x", x},
        {"y", y},
        {"button", button},
        {"timestamp", timestamp},
        {"deltaX", delta_x},
        {"deltaY", delta_y},
        {"modifiers", modifiers},
        {"clickCount", click_count}
      ])

    {"Input.emulateTouchFromMouseEvent", params}
  end

  @doc """
  Ignores input events (useful while auditing page).
  ## Parameters:
    - `ignore`:Ignores input events processing when set to true.
  """
  @spec set_ignore_input_events(boolean()) :: {String.t(), map()}
  def set_ignore_input_events(ignore) do
    params = as_query([{"ignore", ignore}])
    {"Input.setIgnoreInputEvents", params}
  end

  @doc """
  Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
  Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
  ## Parameters:
    - `enabled`:description not provided :(
  """
  @spec set_intercept_drags(boolean()) :: {String.t(), map()}
  def set_intercept_drags(enabled) do
    params = as_query([{"enabled", enabled}])
    {"Input.setInterceptDrags", params}
  end

  @doc """
  Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
  ## Parameters:
    - `x`:X coordinate of the start of the gesture in CSS pixels.
  - `y`:Y coordinate of the start of the gesture in CSS pixels.
  - `scale_factor`:Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
  - `relative_speed`:(Optional) Relative pointer speed in pixels per second (default: 800).
  - `gesture_source_type`:(Optional) Which type of input events to be generated (default: 'default', which queries the platform
  for the preferred input type).
  """
  @spec synthesize_pinch_gesture(
          number(),
          number(),
          number(),
          integer(),
          CDPotion.Domain.Input.GestureSourceType
        ) :: {String.t(), map()}
  def synthesize_pinch_gesture(
        x,
        y,
        scale_factor,
        relative_speed \\ nil,
        gesture_source_type \\ nil
      ) do
    params =
      as_query([
        {"x", x},
        {"y", y},
        {"scaleFactor", scale_factor},
        {"relativeSpeed", relative_speed},
        {"gestureSourceType", gesture_source_type}
      ])

    {"Input.synthesizePinchGesture", params}
  end

  @doc """
  Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
  ## Parameters:
    - `x`:X coordinate of the start of the gesture in CSS pixels.
  - `y`:Y coordinate of the start of the gesture in CSS pixels.
  - `x_distance`:(Optional) The distance to scroll along the X axis (positive to scroll left).
  - `y_distance`:(Optional) The distance to scroll along the Y axis (positive to scroll up).
  - `x_overscroll`:(Optional) The number of additional pixels to scroll back along the X axis, in addition to the given
  distance.
  - `y_overscroll`:(Optional) The number of additional pixels to scroll back along the Y axis, in addition to the given
  distance.
  - `prevent_fling`:(Optional) Prevent fling (default: true).
  - `speed`:(Optional) Swipe speed in pixels per second (default: 800).
  - `gesture_source_type`:(Optional) Which type of input events to be generated (default: 'default', which queries the platform
  for the preferred input type).
  - `repeat_count`:(Optional) The number of times to repeat the gesture (default: 0).
  - `repeat_delay_ms`:(Optional) The number of milliseconds delay between each repeat. (default: 250).
  - `interaction_marker_name`:(Optional) The name of the interaction markers to generate, if not empty (default: "").
  """
  @spec synthesize_scroll_gesture(
          number(),
          number(),
          number(),
          number(),
          number(),
          number(),
          boolean(),
          integer(),
          CDPotion.Domain.Input.GestureSourceType,
          integer(),
          integer(),
          String.t()
        ) :: {String.t(), map()}
  def synthesize_scroll_gesture(
        x,
        y,
        x_distance \\ nil,
        y_distance \\ nil,
        x_overscroll \\ nil,
        y_overscroll \\ nil,
        prevent_fling \\ nil,
        speed \\ nil,
        gesture_source_type \\ nil,
        repeat_count \\ nil,
        repeat_delay_ms \\ nil,
        interaction_marker_name \\ nil
      ) do
    params =
      as_query([
        {"x", x},
        {"y", y},
        {"xDistance", x_distance},
        {"yDistance", y_distance},
        {"xOverscroll", x_overscroll},
        {"yOverscroll", y_overscroll},
        {"preventFling", prevent_fling},
        {"speed", speed},
        {"gestureSourceType", gesture_source_type},
        {"repeatCount", repeat_count},
        {"repeatDelayMs", repeat_delay_ms},
        {"interactionMarkerName", interaction_marker_name}
      ])

    {"Input.synthesizeScrollGesture", params}
  end

  @doc """
  Synthesizes a tap gesture over a time period by issuing appropriate touch events.
  ## Parameters:
    - `x`:X coordinate of the start of the gesture in CSS pixels.
  - `y`:Y coordinate of the start of the gesture in CSS pixels.
  - `duration`:(Optional) Duration between touchdown and touchup events in ms (default: 50).
  - `tap_count`:(Optional) Number of times to perform the tap (e.g. 2 for double tap, default: 1).
  - `gesture_source_type`:(Optional) Which type of input events to be generated (default: 'default', which queries the platform
  for the preferred input type).
  """
  @spec synthesize_tap_gesture(
          number(),
          number(),
          integer(),
          integer(),
          CDPotion.Domain.Input.GestureSourceType
        ) :: {String.t(), map()}
  def synthesize_tap_gesture(x, y, duration \\ nil, tap_count \\ nil, gesture_source_type \\ nil) do
    params =
      as_query([
        {"x", x},
        {"y", y},
        {"duration", duration},
        {"tapCount", tap_count},
        {"gestureSourceType", gesture_source_type}
      ])

    {"Input.synthesizeTapGesture", params}
  end
end
